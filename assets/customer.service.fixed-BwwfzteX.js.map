{"version":3,"file":"customer.service.fixed-BwwfzteX.js","sources":["../../src/services/customer.service.fixed.ts"],"sourcesContent":["import { offlineDb } from './db.service';\nimport { apiClient } from './api.service';\nimport { simpleSyncService } from './sync.service.simple';\n\n// Types defined inline\ninterface Customer {\n  id: string;\n  reference: string;\n  name: string;\n  phone: string | null;\n  email: string | null;\n  address: string;\n  notes: string | null;\n  isArchived: boolean;\n  createdAt: Date;\n  updatedAt: Date;\n  createdBy: string;\n  modifiedBy: string;\n  jobs?: any[];\n}\n\ninterface CreateCustomerRequest {\n  name: string;\n  phone?: string;\n  email?: string;\n  address: string;\n  notes?: string;\n}\n\ninterface UpdateCustomerRequest {\n  name?: string;\n  phone?: string | null;\n  email?: string | null;\n  address?: string;\n  notes?: string | null;\n}\n\ninterface CustomerFilters {\n  search?: string;\n  isArchived?: boolean;\n}\n\n// API endpoints\nconst API_ENDPOINTS = {\n  CUSTOMERS: '/api/customers',\n  CUSTOMER_BY_ID: (id: string) => `/api/customers/${id}`\n};\n\n/**\n * Fixed customer service with proper sync\n */\nclass CustomerServiceFixed {\n  /**\n   * Get all customers - always try API first if online\n   */\n  async getCustomers(filters?: CustomerFilters): Promise<Customer[]> {\n    // If online, fetch from API first\n    if (navigator.onLine) {\n      try {\n        const customers = await apiClient.get<Customer[]>(API_ENDPOINTS.CUSTOMERS);\n        \n        // Save to IndexedDB for offline access\n        for (const customer of customers) {\n          await offlineDb.saveCustomer(customer);\n        }\n        \n        return customers;\n      } catch (error) {\n        console.error('[CustomerService] API fetch failed, falling back to local', error);\n      }\n    }\n    \n    // Offline or API failed - use local data\n    return offlineDb.getCustomers(filters);\n  }\n\n  /**\n   * Get a single customer by ID\n   */\n  async getCustomer(id: string): Promise<Customer | null> {\n    // Try local first for speed\n    const local = await offlineDb.getCustomer(id);\n    \n    // If online, also fetch from API to ensure freshness\n    if (navigator.onLine && !id.startsWith('temp_')) {\n      try {\n        const customer = await apiClient.get<Customer>(API_ENDPOINTS.CUSTOMER_BY_ID(id));\n        await offlineDb.saveCustomer(customer);\n        return customer;\n      } catch (error) {\n        console.error('[CustomerService] API fetch failed for customer', id, error);\n      }\n    }\n    \n    return local;\n  }\n\n  /**\n   * Create a new customer\n   */\n  async createCustomer(data: CreateCustomerRequest): Promise<Customer> {\n    const tempId = `temp_customer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const now = new Date();\n    \n    // Create customer object\n    const customer: Customer = {\n      id: tempId,\n      reference: `TEMP-${Date.now()}`,\n      name: data.name,\n      phone: data.phone || null,\n      email: data.email || null,\n      address: data.address,\n      notes: data.notes || null,\n      isArchived: false,\n      createdAt: now,\n      updatedAt: now,\n      createdBy: 'current-user', // TODO: Get from auth\n      modifiedBy: 'current-user'\n    };\n    \n    // Save locally first\n    await offlineDb.saveCustomer(customer);\n    console.log('[CustomerService] Created customer locally', customer);\n    \n    // Queue for sync\n    await simpleSyncService.queueOperation({\n      operation: 'create',\n      entityType: 'customer',\n      payload: {\n        name: data.name,\n        phone: data.phone,\n        email: data.email,\n        address: data.address,\n        notes: data.notes\n      },\n      timestamp: now\n    });\n    \n    // Try immediate sync if online\n    if (navigator.onLine) {\n      simpleSyncService.syncAll();\n    }\n    \n    return customer;\n  }\n\n  /**\n   * Update an existing customer\n   */\n  async updateCustomer(id: string, data: UpdateCustomerRequest): Promise<Customer> {\n    const existing = await offlineDb.getCustomer(id);\n    if (!existing) {\n      throw new Error('Customer not found');\n    }\n    \n    // Update customer\n    const updated: Customer = {\n      ...existing,\n      ...data,\n      updatedAt: new Date(),\n      modifiedBy: 'current-user' // TODO: Get from auth\n    };\n    \n    // Save locally\n    await offlineDb.saveCustomer(updated);\n    console.log('[CustomerService] Updated customer locally', updated);\n    \n    // Queue for sync if not a temp ID\n    if (!id.startsWith('temp_')) {\n      await simpleSyncService.queueOperation({\n        operation: 'update',\n        entityType: 'customer',\n        entityId: id,\n        payload: data,\n        timestamp: new Date()\n      });\n      \n      // Try immediate sync if online\n      if (navigator.onLine) {\n        simpleSyncService.syncAll();\n      }\n    }\n    \n    return updated;\n  }\n\n  /**\n   * Delete a customer\n   */\n  async deleteCustomer(id: string): Promise<void> {\n    // Delete locally\n    await offlineDb.deleteCustomer(id);\n    console.log('[CustomerService] Deleted customer locally', id);\n    \n    // Queue for sync if not a temp ID\n    if (!id.startsWith('temp_')) {\n      await simpleSyncService.queueOperation({\n        operation: 'delete',\n        entityType: 'customer',\n        entityId: id,\n        payload: {},\n        timestamp: new Date()\n      });\n      \n      // Try immediate sync if online\n      if (navigator.onLine) {\n        simpleSyncService.syncAll();\n      }\n    }\n  }\n\n  /**\n   * Force refresh from server\n   */\n  async refreshFromServer(): Promise<void> {\n    if (!navigator.onLine) {\n      throw new Error('Cannot refresh - device is offline');\n    }\n    \n    try {\n      const customers = await apiClient.get<Customer[]>(API_ENDPOINTS.CUSTOMERS);\n      \n      // Clear local data\n      const localCustomers = await offlineDb.getCustomers();\n      for (const customer of localCustomers) {\n        if (!customer.id.startsWith('temp_')) {\n          await offlineDb.deleteCustomer(customer.id);\n        }\n      }\n      \n      // Save fresh data\n      for (const customer of customers) {\n        await offlineDb.saveCustomer(customer);\n      }\n      \n      console.log('[CustomerService] Refreshed from server', customers.length, 'customers');\n    } catch (error) {\n      console.error('[CustomerService] Failed to refresh from server', error);\n      throw error;\n    }\n  }\n}\n\nexport const customerServiceFixed = new CustomerServiceFixed();"],"names":["API_ENDPOINTS","id","CustomerServiceFixed","filters","customers","apiClient","customer","offlineDb","error","local","data","tempId","now","simpleSyncService","existing","updated","localCustomers","customerServiceFixed"],"mappings":"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"}