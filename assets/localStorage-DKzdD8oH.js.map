{"version":3,"file":"localStorage-DKzdD8oH.js","sources":["../../src/services/localStorageService.ts","../../src/utils/localStorage.ts"],"sourcesContent":["// Local Storage Service - Secure local-only data persistence\n// Following BMAD security principles\n\ninterface StorageKeys {\n  CUSTOMERS: 'khs-crm-customers';\n  JOBS: 'khs-crm-jobs';\n  WORKERS: 'khs-crm-workers';\n  SETTINGS: 'khs-crm-settings';\n  LAST_SYNC: 'khs-crm-last-sync';\n}\n\nexport const STORAGE_KEYS: StorageKeys = {\n  CUSTOMERS: 'khs-crm-customers',\n  JOBS: 'khs-crm-jobs', \n  WORKERS: 'khs-crm-workers',\n  SETTINGS: 'khs-crm-settings',\n  LAST_SYNC: 'khs-crm-last-sync'\n};\n\n// Data classification for future security features\nexport enum DataClassification {\n  PUBLIC = 'public',        // Can be synced freely\n  INTERNAL = 'internal',    // Can be synced within organization\n  CONFIDENTIAL = 'confidential', // Requires encryption for sync\n  RESTRICTED = 'restricted' // Never sync, local only\n}\n\n// Security metadata for stored data\ninterface SecureStorageMetadata {\n  classification: DataClassification;\n  lastModified: string;\n  version: number;\n}\n\nclass LocalStorageService {\n  // Save data with security metadata\n  save<T>(key: string, data: T, classification: DataClassification = DataClassification.RESTRICTED): void {\n    try {\n      const metadata: SecureStorageMetadata = {\n        classification,\n        lastModified: new Date().toISOString(),\n        version: 1\n      };\n\n      const storageData = {\n        data,\n        metadata\n      };\n\n      localStorage.setItem(key, JSON.stringify(storageData));\n      \n      // Trigger storage event for cross-tab sync\n      window.dispatchEvent(new Event('storage'));\n    } catch (error) {\n      console.error(`Failed to save data to ${key}:`, error);\n      throw new Error('Failed to save data');\n    }\n  }\n\n  // Load data with security checks\n  load<T>(key: string): T | null {\n    try {\n      const stored = localStorage.getItem(key);\n      if (!stored) return null;\n\n      const parsed = JSON.parse(stored);\n      \n      // Handle legacy data without metadata\n      if (!parsed.metadata) {\n        // Migrate legacy data to new format\n        this.migrateLegacyData(key, parsed);\n        return parsed as T;\n      }\n\n      return parsed.data as T;\n    } catch (error) {\n      console.error(`Failed to load data from ${key}:`, error);\n      return null;\n    }\n  }\n\n  // Get metadata for stored data\n  getMetadata(key: string): SecureStorageMetadata | null {\n    try {\n      const stored = localStorage.getItem(key);\n      if (!stored) return null;\n\n      const parsed = JSON.parse(stored);\n      return parsed.metadata || null;\n    } catch (error) {\n      console.error(`Failed to get metadata for ${key}:`, error);\n      return null;\n    }\n  }\n\n  // Check if data can be synced based on classification\n  canSync(key: string): boolean {\n    const metadata = this.getMetadata(key);\n    if (!metadata) return false;\n\n    // For now, only allow syncing of non-customer data\n    if (key === STORAGE_KEYS.CUSTOMERS) return false;\n    \n    return metadata.classification !== DataClassification.RESTRICTED;\n  }\n\n  // Migrate legacy data to new secure format\n  private migrateLegacyData(key: string, data: any): void {\n    // Determine classification based on key\n    let classification = DataClassification.INTERNAL;\n    if (key === STORAGE_KEYS.CUSTOMERS) {\n      classification = DataClassification.RESTRICTED;\n    }\n\n    this.save(key, data, classification);\n  }\n\n  // Clear specific data\n  remove(key: string): void {\n    localStorage.removeItem(key);\n    window.dispatchEvent(new Event('storage'));\n  }\n\n  // Clear all app data\n  clearAll(): void {\n    Object.values(STORAGE_KEYS).forEach(key => {\n      localStorage.removeItem(key);\n    });\n    window.dispatchEvent(new Event('storage'));\n  }\n\n  // Get storage size info\n  getStorageInfo(): { used: number; available: number } {\n    let used = 0;\n    \n    Object.values(STORAGE_KEYS).forEach(key => {\n      const data = localStorage.getItem(key);\n      if (data) {\n        used += data.length * 2; // Approximate bytes (UTF-16)\n      }\n    });\n\n    // Most browsers allow ~10MB for localStorage\n    const available = 10 * 1024 * 1024;\n    \n    return { used, available };\n  }\n}\n\n// Export singleton instance\nexport const localStorageService = new LocalStorageService();\n\n// Helper functions for specific data types\nexport const customerStorage = {\n  save: (customers: any[]) => {\n    localStorageService.save(STORAGE_KEYS.CUSTOMERS, customers, DataClassification.RESTRICTED);\n  },\n  \n  load: (): any[] => {\n    return localStorageService.load(STORAGE_KEYS.CUSTOMERS) || [];\n  },\n\n  canSync: (): boolean => {\n    return false; // Customers are always restricted\n  }\n};\n\nexport const jobStorage = {\n  save: (jobs: any[]) => {\n    localStorageService.save(STORAGE_KEYS.JOBS, jobs, DataClassification.INTERNAL);\n  },\n  \n  load: (): any[] => {\n    return localStorageService.load(STORAGE_KEYS.JOBS) || [];\n  }\n};\n\nexport const workerStorage = {\n  save: (workers: any[]) => {\n    localStorageService.save(STORAGE_KEYS.WORKERS, workers, DataClassification.CONFIDENTIAL);\n  },\n  \n  load: (): any[] => {\n    return localStorageService.load(STORAGE_KEYS.WORKERS) || [];\n  }\n};","// Local Storage Utility for KHS CRM\n// SECURITY UPDATE: Customer data is now restricted and cannot be synced\n\nimport { DataClassification } from '../services/localStorageService';\nimport { auditService } from '../services/auditService';\nimport { encryptionService, needsEncryption } from '../services/encryptionService';\n\nconst STORAGE_KEYS = {\n  CUSTOMERS: 'khs_crm_customers',\n  JOBS: 'khs_crm_jobs',\n  MATERIALS: 'khs_crm_materials',\n  PROFILE: 'khs_crm_profile',\n  CALENDAR_JOBS: 'khs_crm_calendar_jobs'\n};\n\n// Data classifications for security - practical approach\nconst DATA_CLASSIFICATIONS = {\n  [STORAGE_KEYS.CUSTOMERS]: DataClassification.PUBLIC, // Business contact info\n  [STORAGE_KEYS.JOBS]: DataClassification.INTERNAL,    // Project details\n  [STORAGE_KEYS.MATERIALS]: DataClassification.PUBLIC, // Supply lists\n  [STORAGE_KEYS.PROFILE]: DataClassification.INTERNAL, // User settings\n  [STORAGE_KEYS.CALENDAR_JOBS]: DataClassification.INTERNAL, // Schedules\n};\n\n// Generic storage functions\nexport const storage = {\n  get: <T>(key: string, defaultValue: T): T => {\n    try {\n      const item = localStorage.getItem(key);\n      if (!item) {\n        return defaultValue;\n      }\n      \n      const parsed = JSON.parse(item);\n      // Handle legacy data without metadata\n      if (!parsed.metadata) {\n        return parsed as T;\n      }\n      \n      // Check if data is encrypted\n      if (parsed.metadata.encrypted && encryptionService.isReady()) {\n        // For now, return encrypted data as-is\n        // TODO: Make storage operations async to support decryption\n        console.warn(`Data for ${key} is encrypted but using sync storage`);\n      }\n      \n      return parsed.data as T;\n    } catch (error) {\n      console.error(`Error reading from localStorage for key ${key}:`, error);\n      return defaultValue;\n    }\n  },\n\n  set: <T>(key: string, value: T): void => {\n    try {\n      const classification = DATA_CLASSIFICATIONS[key] || DataClassification.INTERNAL;\n      \n      // Encrypt if needed and encryption is ready\n      let dataToStore = value;\n      let isEncrypted = false;\n      \n      if (needsEncryption(classification) && encryptionService.isReady()) {\n        // Use async encryption wrapped in a promise\n        const encryptAsync = async () => {\n          dataToStore = await encryptionService.encrypt(value, classification);\n          isEncrypted = true;\n        };\n        \n        // For now, we'll skip encryption in sync context\n        // TODO: Make storage operations async\n        console.warn(`Data for ${key} should be encrypted but using sync storage`);\n      }\n      \n      const storageData = {\n        data: dataToStore,\n        metadata: {\n          classification,\n          lastModified: new Date().toISOString(),\n          version: 1,\n          encrypted: isEncrypted,\n        },\n      };\n      localStorage.setItem(key, JSON.stringify(storageData));\n      // Trigger storage event for cross-tab sync\n      window.dispatchEvent(new Event('storage'));\n    } catch (error) {\n      console.error(`Error writing to localStorage for key ${key}:`, error);\n    }\n  },\n\n  remove: (key: string): void => {\n    try {\n      localStorage.removeItem(key);\n    } catch (error) {\n      console.error(`Error removing from localStorage for key ${key}:`, error);\n    }\n  },\n\n  clear: (): void => {\n    try {\n      Object.values(STORAGE_KEYS).forEach(key => {\n        localStorage.removeItem(key);\n      });\n    } catch (error) {\n      console.error('Error clearing localStorage:', error);\n    }\n  },\n};\n\n// Customer-specific functions - Business data with selective sync\nexport const customerStorage = {\n  getAll: () => {\n    const data = storage.get(STORAGE_KEYS.CUSTOMERS, []);\n    auditService.logAccess('read', 'customers', DataClassification.PUBLIC, { count: data.length });\n    return data;\n  },\n  save: (customers: unknown[]) => {\n    storage.set(STORAGE_KEYS.CUSTOMERS, customers);\n    auditService.logAccess('write', 'customers', DataClassification.PUBLIC, { count: customers.length });\n  },\n  clear: () => {\n    storage.remove(STORAGE_KEYS.CUSTOMERS);\n    auditService.logAccess('delete', 'customers', DataClassification.PUBLIC);\n  },\n  canSync: () => true, // Business data can sync (with field filtering)\n};\n\n// Job-specific functions\nexport const jobStorage = {\n  getAll: () => {\n    const data = storage.get(STORAGE_KEYS.JOBS, []);\n    auditService.logAccess('read', 'jobs', DataClassification.INTERNAL, { count: data.length });\n    return data;\n  },\n  save: (jobs: unknown[]) => {\n    storage.set(STORAGE_KEYS.JOBS, jobs);\n    auditService.logAccess('write', 'jobs', DataClassification.INTERNAL, { count: jobs.length });\n  },\n  clear: () => {\n    storage.remove(STORAGE_KEYS.JOBS);\n    auditService.logAccess('delete', 'jobs', DataClassification.INTERNAL);\n  },\n};\n\n// Material-specific functions\nexport const materialStorage = {\n  getAll: () => {\n    const data = storage.get(STORAGE_KEYS.MATERIALS, []);\n    auditService.logAccess('read', 'materials', DataClassification.PUBLIC, { count: data.length });\n    return data;\n  },\n  save: (materials: unknown[]) => {\n    storage.set(STORAGE_KEYS.MATERIALS, materials);\n    auditService.logAccess('write', 'materials', DataClassification.PUBLIC, { count: materials.length });\n  },\n  clear: () => {\n    storage.remove(STORAGE_KEYS.MATERIALS);\n    auditService.logAccess('delete', 'materials', DataClassification.PUBLIC);\n  },\n};\n\n// Profile-specific functions\nexport const profileStorage = {\n  get: () => {\n    const data = storage.get(STORAGE_KEYS.PROFILE, null);\n    auditService.logAccess('read', 'profile', DataClassification.CONFIDENTIAL);\n    return data;\n  },\n  save: (profile: unknown) => {\n    storage.set(STORAGE_KEYS.PROFILE, profile);\n    auditService.logAccess('write', 'profile', DataClassification.CONFIDENTIAL);\n  },\n  clear: () => {\n    storage.remove(STORAGE_KEYS.PROFILE);\n    auditService.logAccess('delete', 'profile', DataClassification.CONFIDENTIAL);\n  },\n};\n\n// Calendar jobs specific functions\nexport const calendarJobStorage = {\n  getAll: () => {\n    const jobs = storage.get(STORAGE_KEYS.CALENDAR_JOBS, []);\n    // Convert date strings back to Date objects\n    return jobs.map((job: Record<string, unknown>) => ({\n      ...job,\n      startDate: new Date(job.startDate as string),\n      endDate: new Date(job.endDate as string),\n    }));\n  },\n  save: (jobs: Array<Record<string, unknown>>) => {\n    // Convert Date objects to strings for storage\n    const jobsToStore = jobs.map(job => ({\n      ...job,\n      startDate: (job.startDate as Date).toISOString(),\n      endDate: (job.endDate as Date).toISOString(),\n    }));\n    storage.set(STORAGE_KEYS.CALENDAR_JOBS, jobsToStore);\n  },\n  clear: () => storage.remove(STORAGE_KEYS.CALENDAR_JOBS),\n};"],"names":["DataClassification","STORAGE_KEYS","DATA_CLASSIFICATIONS","storage","key","defaultValue","item","parsed","encryptionService","error","value","classification","dataToStore","isEncrypted","needsEncryption","encryptAsync","storageData","customerStorage","data","auditService","customers","profileStorage","profile","calendarJobStorage","job","jobs","jobsToStore"],"mappings":"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"}